grammar AST
	rule space
		[ \t]
	end

	rule newline
		"\r"? "\n" / "\r"
	end

	rule s
		space*
	end

	rule S
		!ident_char s
	end

	rule n
		s !(!newline .) newline? s
	end

	rule l
		(space / newline)*
	end

	rule number
		 [0-9]+ { def value; text_value.to_i end }
	end
	
	rule string
		'"' ('\"' / !'"' .)* '"' { def value; text_value end }
	end
	
	rule ident_char
		[_A-Za-z0-9]
	end
	
	rule ident
		s ([_A-Za-z]+ ident_char*) { def value; text_value.to_sym end }
	end
	
	rule program
		global_scope_entries
	end
	
	rule global_scope
		l '{' global_scope_entries '}' n
	end
	
	rule global_scope_entries
		(l global_scope_entry)* l { def ast; Program.new(GlobalScope.new(auto_ast)) end }
	end
	
	rule global_scope_entry
		struct
		/ function
	end
	
	rule struct
		s 'struct' S ident global_scope
	end
	
	rule function_attribute
		attrib:('import' / 'export') S { def value; attrib.text_value.to_sym end }
	end
	
	rule function
		attribs:function_attribute* ident function_parameters result:(type_specifier?) group:(group_braced?) {
			def ast
				func = Function.new
				func.source = source
				func.name = ident.value
				func.params = function_parameters.ast
				func.result = single_ast(result)
				func.attributes = attribs.elements.map(&:value)
				func.scope = single_ast(group)
				func
			end
		}
	end
	
	rule function_parameters
		s '(' l (function_parameter (s ',' l function_parameter)* l)? ')'
	end
	
	rule function_parameter
		ident type:(type_specifier?) { def ast; Function::Parameter.new(source, ident.value, single_ast(type)) end }
	end
	
	rule type_specifier
		s ':' l type
	end
	
	rule type
		ident { def ast; NamedTypeNode.new(source, value) end }
		/ '^' l type { def ast; NullPtrTypeNode.new(source, type.ast) end }
		/ '*' l type { def ast; PtrTypeNode.new(source, type.ast) end }
	end
	
	rule group_braced
		l '{' l (expression (n l expression)* l)? '}' { def ast; LocalScope.new(auto_ast) end }
	end
	
	rule group
		n expression n { def ast; LocalScope.new(auto_ast) end }
		/ group_braced
	end
	
	rule expression
		return
		/ if
		/ assignment
	end

	rule return
		'return' l expression { def ast; Return.new(single_ast(expression)) end }
	end

	rule if
		'if' S l expression group else_opt:('else' S group)? { def ast; If.new(single_ast(expression), single_ast(group), single_ast(else_opt)) end }
	end

	rule assignment_right
		s op:([+\-*/%]? "=") l additive { def ast; rhe op, additive end }
	end

	rule assignment
		additive rl:assignment_right* { def ast; merge_rhe(additive, rl, false) end }
	end

	rule additive_right
		s op:[+\-] l multitive { def ast; rhe op, multitive end }
	end

	rule additive
		multitive rl:additive_right* { def ast; merge_rhe(multitive, rl) end }
	end

	rule multitive_right
		s op:[*/%] l unary { def ast; rhe op, unary end }
	end

	rule multitive
		unary rl:multitive_right* { def ast; merge_rhe(unary, rl) end }
	end

	rule unary
		(s [+-] l)? factor
	end

	rule arguments
		(expression (s ',' l expression)*)?
	end
	
	rule call
		ident s '(' l arguments l ')' { def ast; Call.new(source, ident.value, auto_ast) end }
	end
	
	rule variable_decl
		ident type_value:(
			type_specifier expr:(s "=" l expression)? { def ast; {type: single_ast(type_specifier), value: single_ast(expr)} end }
			/ s ":=" l expression { def ast; {value: single_ast(expression)} end }
		) {
			def ast
				tv = single_ast(type_value)
				VariableDecl.new(ident.source, type_value.source, ident.value, tv[:type], tv[:value])
			end
		} 
	end

	rule variable_decls
		variable_decl (s "," l variable_decl)*
	end

	rule factor
		s '(' l expression l ')'
		/ number { def ast; Literal.new(source, :int, value) end }
		/ string { def ast; Literal.new(source, :string, value) end }
		/ "true" { def ast; Literal.new(source, :bool, true) end }
		/ "false" { def ast; Literal.new(source, :bool, false) end }
		/ call
		/ variable_decls
		/ ident { def ast; VariableRef.new(source, value) end }
	end
end