grammar Hush
	rule space
		[ \t]
	end

	rule newline
		"\r"? "\n" / "\r"
	end

	rule s
		space*
	end

	rule S
		!ident_char l
	end

	rule n
		s !(!newline .) newline? s
	end

	rule l
		(space / newline)*
	end

	rule number
		 [0-9]+
	end
	
	rule string
		'"' ('\"' / !'"' .)* '"' { def value; text_value end }
	end
	
	rule ident_char
		[_A-Za-z0-9]
	end
	
	rule ident
		s ([_A-Za-z]+ ident_char*) { def value; text_value.to_sym end }
	end
	
	rule program
		global_scope_entries
	end
	
	rule global_scope
		l '{' global_scope_entries '}' n
	end
	
	rule global_scope_entries
		(l global_scope_entry)* l { def ast; [:global_scope, auto_ast] end }
	end
	
	rule global_scope_entry
		struct
		/ function
	end
	
	rule struct
		s 'struct' S ident global_scope
	end
	
	rule function_attribute
		attrib:('import' / 'export') S { def value; attrib.text_value.to_sym end }
	end
	
	rule function
		attribs:function_attribute* ident function_parameters result:(type_specifier?) group:(group_braced?) {
			def ast
				[:func,
					{name: ident.value,
					params: auto_ast(function_parameters, false),
					result: opt_ast(result),
					attribs: attribs.elements.map(&:value),
					group: opt_ast(group)}
				]
			end
		}
	end
	
	rule function_parameters
		s '(' l (function_parameter (s ',' l function_parameter)* l)? ')'
	end
	
	rule function_parameter
		ident type:(type_specifier?) { def ast; [ident.value, opt_ast(type)] end }
	end
	
	rule type_specifier
		s ':' l type
	end
	
	rule type
		ident { def ast; value end }
		/ '^' l type { def ast; [:null_ptr, type.ast] end }
		/ '*' l type { def ast; [:ptr, type.ast] end }
	end
	
	rule group_braced
		l '{' l (expression (n l expression)* l)? '}' { def ast; [:group, auto_ast] end }
	end
	
	rule group
		n expression n { def ast; [:group, auto_ast] end }
		/ group_braced
	end
	
	rule expression
		additive
		/ return
		/ if
	end

	rule if
		'if' S expression group ('else' S expression group)?
	end

	rule return
		'return' l expression
	end

	rule additive
		multitive ( s [+-] l multitive )*
	end

	rule multitive
		unary ( s [*/%] l unary )*
	end

	rule unary
		(s [+-] l)? factor
	end

	rule arguments
		(expression (s ',' l expression)*)?
	end
	
	rule call
		ident s '(' l arguments l ')' { def ast; [:call, ident.value, auto_ast] end }
	end
	
	rule factor
		s '(' l expression l ')'
		/ number
		/ string { def ast; [:string, value] end }
		/ call
	end
end