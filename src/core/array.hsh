struct Array(T, A Allocator = Mem)
	list *T
	size uint
	capacity uint
	allocator A

	shared unit = size_of[T]()

	action create :
			list <- Allocator(allocator).alloc(0),
			size <- 0,
			capacity <- 0
	
	action copy
		.b = size * unit
		.new = Allocator(allocator).alloc(b)
		Mem.copy(list, new, b)
		list = new
		capacity = size

	action destroy
		Allocator(allocator).free(list)

	fn each(f)
		times(size, |i| f(*ptr_idx(list, i)))

	fn expand(n)
		if capacity >= size + n
			return

		loop
			capacity = 2 * (capacity + 1)
			if(capacity >= size + n)
				break

		list = Allocator(allocator).realloc(list, size * unit, capacity * unit)

	fn push(val)
		expand(1)
		*list = val
		size += 1

	fn ptr(idx uint) -> *T
		return ptr_idx(list, idx)

	fn get(idx uint)
		return *ptr(idx)

instance(T) Callable(Array(T))
	alias Result = T
	alias Args = Cell(uint, Unit)

	fn apply(args Cell(uint, Unit))
		return self.get(args.val)

instance(T) Indexable(Array(T))
	alias Result = T
	alias Index = Cell(uint, Unit)

	fn ref(args Cell(uint, Unit))
		return self.ptr(args.val)
