struct Array(T, A Allocator = Mem)
	list *T
	size uint
	capacity uint
	allocator A

	shared unit = size_of[T]()

	action create :
			list <- Allocator(allocator).alloc(0),
			size <- 0,
			capacity <- 0
	
	action copy
		.b = size * unit
		.new = Allocator(allocator).alloc(b)
		Mem.copy(list, new, b)
		list = new
		capacity = size

	action destroy
		Allocator(allocator).free(list)

	fn each(f)
		times(size, |i| f(*ptr_idx(list, i)))

	fn each_with_index(f)
		times(size, |i| f(*ptr_idx(list, i), i))

	fn reverse()
		.result Array
		result.expand(size)
		times(size, |i| *ptr_idx(result.list, i) = *ptr_idx(list, size - 1 - i))
		return result

	fn slice(start, stop)
		.result Array
		if start > stop
			return result
		.size = stop - start + 1
		result.expand(size)
		times(size, |i| *ptr_idx(result.list, i) = *ptr_idx(list, start + i))
		return result

	fn expand(n)
		if capacity >= size + n
			return

		loop
			capacity = 2 * (capacity + 1)
			if capacity >= size + n
				break

		list = Allocator(allocator).realloc(list, size * unit, capacity * unit)

	fn last()
		return if size > 0
			some(*ptr_idx(list, size - 1))
		else
			Option.None()

	fn push(val)
		expand(1)
		*ptr_idx(list, size) = val
		size += 1

	fn ptr(idx uint) -> *T
		return ptr_idx(list, idx)

	fn get(idx uint)
		return *ptr(idx)

instance(T) Callable(Array(T))
	alias Result = T
	alias Args = Cell(uint, Unit)

	fn apply(args Cell(uint, Unit))
		return self.get(args.val)

instance(T) Indexable(Array(T))
	alias Result = T
	alias Index = Cell(uint, Unit)

	fn ref(args Cell(uint, Unit))
		return self.ptr(args.val)
