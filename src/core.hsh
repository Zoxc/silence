use "core/import"
use "core/array"
use "core/map"
use "core/string"
use "core/io"
use "core/file"
use "core/builtin"

class Hash(T)
	fn hash() -> uint

class Allocator(T)
	fn alloc[P](size uint) -> *P
	fn realloc[P](ptr *P, old_size uint, new_size uint) -> *P
	fn free[P](ptr *P)

class RefConstructable(T)
	type_func Header
	shared fn construct(obj *Header, allocator) -> T

instance(T) RefConstructable(*T)
	alias Header = ()
	shared fn construct(obj *(), allocator) -> *T
		return ptr_cast ptr_succ(obj)

fn allocate[T, Ref](args, allocator) -> Ref
	.size = size_of[RefConstructable(Ref).Header]() + size_of[Constructor(T).Constructed]()
	.obj = Allocator(allocator).alloc(size)
	.result = ptr_cast ptr_succ(obj)
	Constructor[T].construct(result, args)
	return RefConstructable[Ref].construct(obj, allocator)

fn destruct(obj)
	
struct Mem
	shared fn alloc(size uint)
		return ptr_cast C.malloc(size)

	shared fn realloc[T](ptr *T, old_size uint, new_size uint) -> *T
		return ptr_cast C.realloc(ptr_cast ptr, new_size)

	shared fn copy[T](src *T, dst *T, size)
		C.memcpy(ptr_cast dst, ptr_cast src, size)

	shared fn cmp[T](a *T, b *T, size) -> bool
		return C.memcmp(ptr_cast a, ptr_cast b, size) == 0

	shared fn free(ptr)
		C.free(ptr_cast ptr)

	action create

instance Allocator(Mem)
	fn alloc[P](size uint) -> *P
		return self.alloc(size)

	fn realloc[P](ptr *P, old_size uint, new_size uint) -> *P
		return self.realloc(ptr, old_size, new_size)

	fn free[P](ptr *P)
		self.free(ptr)

fn new[T Constructor = Reference(R).Type, R] *args -> R
	return allocate[T](args, Mem())

fn delete(obj)
	destruct(obj)
	Mem.free(obj)

instance(T) Reference(*T)
	alias Type = T

	fn get() -> *T
		return self

class Show(T)
	fn show() -> String

instance Show(int)
	fn show()
		.r = undef()
		Runtime.hush_show_int(&r, self)
		return r

instance Show(uint)
	fn show()
		.r = undef()
		Runtime.hush_show_uint(&r, self)
		return r

instance Show(String)
	fn show()
		return self

fn show(t)
	return Show(t).show()

instance StringLiteral(*char)
	fn create(data *char, size uint)
		return data

instance StringLiteral(char)
	fn create(data *char, size uint)
		assert -> size == 1
		return *data

instance(T) Eq(*T)
	fn equal(lhs *T, rhs *T)
		return force_cast[uint] lhs == force_cast rhs

fn min(a, b)
	return if a > b
		b
	else
		a

fn max(a, b)
	return if a < b
		b
	else
		a

fn assert(b)
	if !b()
		IO.puts("Assertion failed!")
		C.abort()

fn some(val)
	return Option.Some(val)

fn ptr_cast[R, P](p *P) -> R
	return force_cast(p)

fn ptr_int[P](p *P)
	return force_cast[uint](p)

fn is_nil_ptr(p)
	return ptr_int(p) == 0

fn nil_ptr[P]() -> *P
	.z uint = 0
	return force_cast z

fn times_impl(i, max, f)
	if i > 0
		f(max - i)
		times_impl(i - 1, max, f)

fn times(i, f)
	times_impl(i, i, f)

fn for_range(a, b, f)
	.i uint = force_cast(b - a) + 1
	times(i, |i| f(a + force_cast i))

fn ptr_idx[T](ptr *T, idx uint) -> *T
	return force_cast(force_cast ptr + idx * size_of[T]())

fn ptr_pred[T](ptr *T) -> *T
	return force_cast(force_cast ptr - size_of[T]())

fn ptr_diff[T](lhs *T, rhs *T) -> uint
	return (force_cast[uint] lhs - force_cast rhs) / size_of[T]()

fn ptr_succ[T](ptr *T) -> *T
	return force_cast(force_cast ptr + size_of[T]())

instance(T Indexable) Callable(T)
	alias Result = Indexable(T).Result
	alias Args = Indexable(T).Index

	fn apply(args Args)
		return *Indexable(self).ref(args)

instance(T Indexable) Indexable(*T)
	alias Result = Indexable(T).Result
	alias Index = Indexable(T).Index

	fn ref(index Index)
		return Indexable(*self).ref(index)
