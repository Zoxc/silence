use "../core"
use "source"

enum Token
	None
	Unknown
	Ident
	Number
	EndOfFile

	# Order binary operators

	Add
	Sub
	Mul
	Div
	Mod

	# Keep the assigns in the same order as the binary operators

	AssignAdd
	AssignSub
	AssignMul
	AssignDiv
	AssignMod

struct ref Lexer
	struct State
		pos *char
		input_end *char

		lexer *Lexer
		type Token
		start *char
		stop *char

		action create(pos, end, lexer) :
			pos <- pos,
			input_end <- end,
			lexer <- lexer,
			type <- Token.None,
			start <- undef(),
			stop <- undef()

		fn end()
			stop = pos

		fn str()
			return String.from_data(start, ptr_diff(stop, start))

	compiler *Compiler
	tok State
	file *SrcFile
	jump_table Table(256, () -> ())

	fn c()
		return *tok.pos

	fn at_end()
		return tok.pos == tok.input_end

	fn step()
		assert -> !at_end()
		tok.pos = ptr_idx(tok.pos, 1)
		return *tok.pos

	fn in(a, b)
		return (a <= c()) & (c() <= b)

	fn src() -> *SrcLoc
		return new(file, tok.start, tok.stop)

	fn report[T] *args
		.error = Callable(new[T]).apply(Cell(src(), args))
		compiler.errors.push error

	action create(compiler, file) :
		compiler <- compiler,
		file <- file,
		tok <- State(file.content.data, ptr_idx(file.content.data, file.content.size - 1), &self),
		jump_table <- undef()

		setup_table()
		next_token()

	fn setup_table()
		.set_char = |i char, f|
			jump_table(force_cast i) = f

		.set_chars = |start char, stop, f|
			for_range(start, stop, |i| set_char(i, f))

		set_chars(0, 255, unknown)

		set_chars("0", "9", number)

		set_chars("A", "Z", ident)
		set_chars("a", "z", ident)
		set_char("_", ident)

		set_char(" ", whitespace)
		set_char(9, whitespace)


		set_char("+", assign[Token.Add, Token.AssignAdd])

		set_char(0, eof)

	fn next_token()
		tok.type = Token.None
		tok.start = tok.pos

		jump_table(force_cast c())()

		assert -> ptr_int tok.stop >= ptr_int tok.start
		assert -> tok.type != Token.None

	fn assign[type :: Token, assign_type :: Token]()
		step()

		tok.type = if c() == "="
			step()
			assign_type
		else
			type

		tok.end()

	fn eof()
		if at_end()
			tok.type = Token.EndOfFile
			tok.end()
		else
			tok.end()
			report[Error.NullChar]()
			step()
			next_token()

	fn number()
		step()

		loop
			if !in("0", "9")
				break
			step()

		tok.end()
		tok.type = Token.Number

	fn whitespace()
		loop
			step()

			if c() != " " or c() != 9
				break
		next_token()

	fn ident()
		step()

		loop
			if !(in("0", "9") or in("A", "Z") or in("a", "z") or c() == "_")
				break
			step()

		tok.end()
		tok.type = Token.Ident

	fn unknown()
		step()

		loop
			if jump_table(force_cast c()) != unknown
				break
			step()

		tok.end()

		report[Error.UnknownChars]()

		next_token()
