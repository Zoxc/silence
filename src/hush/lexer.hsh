use "../core"
use "source"

enum Token
	None
	Unknown
	Ident
	Number
	EndOfFile

	Not
	Comma
	Dot
	Colon
	DoubleColon

	Eq
	NotEq

	Greater
	GreaterOrEq
	Less
	LessOrEq

	ArrowLeft
	ArrowRight

	Assign

	# Ordered
	
	ParentOpen
	SquareOpen
	BraceOpen

	ParentClose
	SquareClose
	BraceClose

	# Ordered binary operators

	Add
	Sub
	Mul
	Div
	Mod

	Or
	And
	Xor

	Join

	# Keep the assigns in the same order as the binary operators

	AssignAdd
	AssignSub
	AssignMul
	AssignDiv
	AssignMod

	AssignOr
	AssignAnd
	AssignXor

	AssignJoin

struct ref Lexer
	struct State
		pos *char
		input_end *char

		lexer *Lexer
		type Token
		start *char
		stop *char

		action create(pos, end, lexer) :
			pos <- pos,
			input_end <- end,
			lexer <- lexer,
			type <- Token.None,
			start <- undef(),
			stop <- undef()

		fn end()
			stop = pos

		fn str()
			return String.from_data(start, ptr_diff(stop, start))

	compiler *Compiler
	tok State
	file *SrcFile
	jump_table Table(256, () -> ())
	blocks Array(*Block)

	struct ref Block
		levels Table(3, uint)

		action create() :
			levels <- undef()
			levels(0) = 0
			levels(1) = 0
			levels(2) = 0

	fn c()
		return *tok.pos

	fn at_end()
		return tok.pos == tok.input_end

	fn step()
		assert -> !at_end()
		tok.pos = ptr_idx(tok.pos, 1)
		return *tok.pos

	fn in(a, b)
		return (a <= c()) & (c() <= b)

	fn src() -> *SrcLoc
		return new(file, tok.start, tok.stop)

	fn report[T] *args
		.error = Callable(new[T]).apply(Cell(src(), args))
		compiler.errors.push error

	action create(compiler, file) :
		compiler <- compiler,
		file <- file,
		tok <- State(file.content.data, ptr_idx(file.content.data, file.content.size - 1), &self),
		jump_table <- undef()

		setup_table()
		next_token()

	fn setup_table()
		.set_char = |i char, f|
			jump_table(force_cast i) = f

		.set_chars = |start char, stop, f|
			for_range(start, stop, |i| set_char(i, f))

		set_chars(0, 255, unknown)

		set_chars("0", "9", number)

		set_chars("A", "Z", ident)
		set_chars("a", "z", ident)
		set_char("_", ident)

		set_char("(", bracket_push)
		set_char("{", bracket_push)
		set_char("[", bracket_push)

		set_char(")", bracket_pop)
		set_char("}", bracket_pop)
		set_char("]", bracket_pop)

		set_char(" ", whitespace)
		set_char(9, whitespace)

		set_char("=", dual[Token.Assign, "=", Token.Eq])
		set_char(":", dual[Token.Colon, ":", Token.DoubleColon])
		set_char("!", dual[Token.Not, ":", Token.NotEq])

		set_char(".", single[Token.Dot])
		set_char(",", single[Token.Comma])

		set_char(">", assign[Token.Greater, Token.GreaterOrEq])
		set_char("<", tri[Token.Less, "=", Token.LessOrEq, "-", Token.ArrowLeft])

		set_char("+", assign[Token.Add, Token.AssignAdd])
		set_char("-", tri[Token.Sub, "=", Token.AssignSub, ">", Token.ArrowRight])
		set_char("*", assign[Token.Mul, Token.AssignMul])
		set_char("/", assign[Token.Div, Token.AssignDiv])
		set_char("%", assign[Token.Mod, Token.AssignMod])

		set_char("|", assign[Token.Or, Token.AssignOr])
		set_char("&", assign[Token.And, Token.AssignAnd])
		set_char("^", assign[Token.Xor, Token.AssignXor])

		set_char("~", assign[Token.Join, Token.AssignJoin])

		set_char(0, eof)

	fn next_token()
		tok.type = Token.None
		tok.start = tok.pos

		jump_table(force_cast c())()

		assert -> ptr_int tok.stop >= ptr_int tok.start
		assert -> tok.type != Token.None

	fn pop_bracket_level(i)

	fn bracket_data() -> uint
		.i
		(tok.type, i) = match c()
			when "("
				(Token.ParentOpen, 0)
			when "["
				(Token.SquareOpen, 1)
			when "{"
				(Token.BraceOpen, 2)
			when ")"
				(Token.ParentClose, 0)
			when "]"
				(Token.SquareClose, 1)
			when "}"
				(Token.BraceClose, 2)
		step()
		tok.end()
		return i

	fn bracket_push()
		.i = bracket_data()
		#blocks.last().map -> |b| b.levels[i] += 1

	fn bracket_pop()
		.i = bracket_data()
		#blocks.last().map -> |b| pop_bracket_level i

	fn tri[type :: Token, c1 :: char, t1 :: Token, c2 :: char, t2 :: Token]()
		step()

		tok.type = match c()
			when c1
				step()
				t1
			when c2
				step()
				t2
			else
				type

		tok.end()

	fn dual[type :: Token, ch :: char, c_type :: Token]()
		step()

		tok.type = if c() == ch
			step()
			c_type
		else
			type

		tok.end()

	fn single[type :: Token]()
		step()
		tok.type = type
		tok.end()

	fn assign[type :: Token, assign_type :: Token]()
		dual[type, "=", assign_type]()

	fn eof()
		if at_end()
			tok.type = Token.EndOfFile
			tok.end()
		else
			tok.end()
			report[Error.NullChar]()
			step()
			next_token()

	fn number()
		step()

		loop
			if !in("0", "9")
				break
			step()

		tok.end()
		tok.type = Token.Number

	fn whitespace()
		loop
			step()

			if c() != " " or c() != 9
				break
		next_token()

	fn ident()
		step()

		loop
			if !(in("0", "9") or in("A", "Z") or in("a", "z") or c() == "_")
				break
			step()

		tok.end()
		tok.type = Token.Ident

	fn unknown()
		step()

		loop
			if jump_table(force_cast c()) != unknown
				break
			step()

		tok.end()

		report[Error.UnknownChars]()

		next_token()
