use "../core"
use "source"

enum Token
	None
	Unknown
	Ident
	Number
	EndOfFile
	Line
	Indent
	Deindent

	Not
	Comma
	Dot
	Colon
	DoubleColon

	Eq
	NotEq

	Greater
	GreaterOrEq
	Less
	LessOrEq

	ArrowLeft
	ArrowRight

	Assign

	ParentOpen
	SquareOpen
	BraceOpen

	ParentClose
	SquareClose
	BraceClose

	# Ordered binary operators

	Add
	Sub
	Mul
	Div
	Mod

	Or
	And
	Xor

	Join

	# Keep the assigns in the same order as the binary operators

	AssignAdd
	AssignSub
	AssignMul
	AssignDiv
	AssignMod

	AssignOr
	AssignAnd
	AssignXor

	AssignJoin

struct ref Lexer
	struct Indent
		start *char
		stop *char

		fn size()
			return ptr_diff(stop, start)

		fn subset(other Indent)
			.s = size()
			if other.size() < s
				return false
			other = Indent(other.start, ptr_idx(other.start, s))
			return Mem.cmp(start, other.start, s)

	struct State
		pos *char
		input_end *char

		lexer *Lexer
		type Token
		start *char
		stop *char
		last_ended *char

		indent Indent

		num uint

		action create(pos, end, lexer) :
			pos <- pos,
			last_ended <- pos,
			input_end <- end,
			lexer <- lexer,
			type <- Token.None,
			start <- undef(),
			stop <- undef(),
			indent <- undef()

		fn end()
			stop = pos

		fn str()
			return String.from_data(start, ptr_diff(stop, start))

	struct ref Block
		levels Table(3, uint)
		indent Indent

		action create(indent) :
			indent <- indent,
			levels <- undef()
			levels(0) = 0
			levels(1) = 0
			levels(2) = 0

		fn ignore()
			return levels(0) > 0 or levels(1) > 0 or levels(2) > 0

	compiler *Compiler
	tok State
	file *SrcFile
	jump_table Table(256, () -> ())
	blocks Array(*Block)

	fn c()
		return *tok.pos

	fn at_end()
		return tok.pos == tok.input_end

	fn step()
		assert -> !at_end()
		tok.pos = ptr_idx(tok.pos, 1)
		return *tok.pos

	fn in(a, b)
		return (a <= c()) & (c() <= b)

	fn make_src(start, stop) -> *SrcLoc
		return new(file, start, stop)

	fn src() -> *SrcLoc
		return make_src(tok.start, tok.stop)

	fn report[T] *args
		.error = Callable(new[T]).apply(args)
		compiler.errors.push error

	action create(compiler, file) :
		compiler <- compiler,
		file <- file,
		tok <- State(file.content.data, ptr_idx(file.content.data, file.content.size - 1), &self),
		jump_table <- undef()

		setup_table()
		next_token()

	fn setup_table()
		.set_char = |i char, f|
			jump_table(force_cast i) = f

		.set_chars = |start char, stop, f|
			for_range(start, stop, |i| set_char(i, f))

		set_chars(0, 255, unknown)

		set_chars("0", "9", number)

		set_chars("A", "Z", ident)
		set_chars("a", "z", ident)
		set_char("_", ident)

		set_char("(", bracket_push)
		set_char("{", bracket_push)
		set_char("[", bracket_push)

		set_char(")", bracket_pop)
		set_char("}", bracket_pop)
		set_char("]", bracket_pop)

		set_char(" ", whitespace)
		set_char(9, whitespace)

		set_char(10, single[Token.Line])
		set_char(13, dual[Token.Line, 10, Token.Line])

		set_char("=", dual[Token.Assign, "=", Token.Eq])
		set_char(":", dual[Token.Colon, ":", Token.DoubleColon])
		set_char("!", dual[Token.Not, ":", Token.NotEq])

		set_char(".", single[Token.Dot])
		set_char(",", single[Token.Comma])

		set_char(">", assign[Token.Greater, Token.GreaterOrEq])
		set_char("<", tri[Token.Less, "=", Token.LessOrEq, "-", Token.ArrowLeft])

		set_char("+", assign[Token.Add, Token.AssignAdd])
		set_char("-", tri[Token.Sub, "=", Token.AssignSub, ">", Token.ArrowRight])
		set_char("*", assign[Token.Mul, Token.AssignMul])
		set_char("/", assign[Token.Div, Token.AssignDiv])
		set_char("%", assign[Token.Mod, Token.AssignMod])

		set_char("|", assign[Token.Or, Token.AssignOr])
		set_char("&", assign[Token.And, Token.AssignAnd])
		set_char("^", assign[Token.Xor, Token.AssignXor])

		set_char("~", assign[Token.Join, Token.AssignJoin])

		set_char(0, eof)

	fn next(process)
		tok.last_ended = tok.pos
		tok.type = Token.None
		tok.start = tok.pos
		tok.stop = ptr_succ tok.pos

		process()

		assert -> ptr_int tok.stop >= ptr_int tok.start
		assert -> tok.type != Token.None

	fn process_token()
		jump_table(force_cast c())()

	fn next_token()
		assert -> tok.type != Token.Line and tok.type != Token.Deindent
		next(process_token)

	fn next_token_after_line()
		assert -> tok.type == Token.Line

		next ->
			tok.indent = get_line_indent()
			handle_line()

	fn skip_newline()
		loop
			match c()
				when 0
					if at_end()
						break
					else
						report[Error.NullChar](make_src(tok.pos, ptr_succ tok.pos))
						step()
				when 13
					step()
					if c() == 10
						step()
					break
				when 10
					step()
					break
				else
					step()

	fn get_line_indent() -> Indent
		.start = tok.pos
		skip_whitespace()

		return match c()
			when 13
				step()
				if c() == 10
					step()
				get_line_indent()
			when 10
				step()
				get_line_indent()
			when "#"
				skip_newline()
				get_line_indent()
			else
				Indent(start, tok.pos)

	enum IndentChange
		Unchanged
		Increased
		Decreased
		Error

	fn compare_indent(old Indent, new Indent)
		return if old.subset(new)
			if new.size() > old.size()
				IndentChange.Increased
			else
				IndentChange.Unchanged
		else if new.subset(old)
			IndentChange.Decreased
		else
			IndentChange.Error

	fn handle_line()
		.block = undef()

		match blocks.last() as b_
			when Option.Some
				block = b_.val
				if block.ignore()
					next(process_token)
					return
			else
				next(process_token)
				return

		match compare_indent(block.indent, tok.indent)
			when IndentChange.Unchanged, IndentChange.Decreased
				blocks.pop()
				.i = 1
				loop
					match blocks.last() as b
						when Option.Some
							if b.val.ignore()
								break
							match compare_indent(b.val.indent, tok.indent)
								when IndentChange.Unchanged, IndentChange.Decreased
								else
									break
						else
							break
					i += 1
					blocks.pop()
				
				tok.start = tok.pos
				tok.end()
				tok.type = Token.Deindent
				tok.num = i * 2
			when IndentChange.Increased
				next(process_token)
			when IndentChange.Error
				report[Error.IndentMismatch](make_src(tok.indent.start, tok.indent.stop), make_src(block.indent.start, block.indent.stop))

	fn pop_bracket_level(brace) -> uint
		blocks.reverse().each_with_index -> |b, i|
			if b.levels(brace) > 0
				b.levels(brace) -= 1
				blocks = blocks.slice(0, blocks.size - 1 - i)
				return i
		return 0

	fn bracket_data() -> uint
		.i
		(tok.type, i) = match c()
			when "("
				(Token.ParentOpen, 0)
			when "["
				(Token.SquareOpen, 1)
			when "{"
				(Token.BraceOpen, 2)
			when ")"
				(Token.ParentClose, 0)
			when "]"
				(Token.SquareClose, 1)
			when "}"
				(Token.BraceClose, 2)
		return i

	fn bracket_push()
		.i = bracket_data()
		step()
		tok.end()
		blocks.last().map -> |b| b.levels(i) += 1

	fn bracket_pop()
		.i = bracket_data()
		if blocks.size > 0
			.p = pop_bracket_level i
			if p > 0
				tok.end()
				tok.type = Token.Deindent
				tok.num = p * 2 - 1
				return
		step()
		tok.end()

	fn tri[type :: Token, c1 :: char, t1 :: Token, c2 :: char, t2 :: Token]()
		step()

		tok.type = match c()
			when c1
				step()
				t1
			when c2
				step()
				t2
			else
				type

		tok.end()

	fn dual[type :: Token, ch :: char, c_type :: Token]()
		step()

		tok.type = if c() == ch
			step()
			c_type
		else
			type

		tok.end()

	fn single[type :: Token]()
		step()
		tok.type = type
		tok.end()

	fn assign[type :: Token, assign_type :: Token]()
		dual[type, "=", assign_type]()

	fn eof()
		if at_end()
			tok.end()

			if blocks.size > 0
				tok.type = Token.Deindent
				tok.num = blocks.size * 2
			else
				tok.type = Token.EndOfFile
		else
			step()
			tok.end()
			report[Error.NullChar](src())
			next(process_token)

	fn number()
		step()

		loop
			if !in("0", "9")
				break
			step()

		tok.end()
		tok.type = Token.Number

	fn skip_whitespace()
		loop
			if c() != " " or c() != 9
				break

			step()

	fn whitespace()
		step()
		skip_whitespace()
		next(process_token)

	fn ident()
		step()

		loop
			if !(in("0", "9") or in("A", "Z") or in("a", "z") or c() == "_")
				break
			step()

		tok.end()
		tok.type = Token.Ident

	fn unknown()
		step()

		loop
			if jump_table(force_cast c()) != unknown
				break
			step()

		tok.end()

		report[Error.UnknownChars](src())

		next(process_token)
